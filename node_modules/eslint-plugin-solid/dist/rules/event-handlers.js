"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const utils_2 = require("../utils");
const { getStaticValue } = utils_1.ASTUtils;
const COMMON_EVENTS = {
    animationend: "AnimationEnd",
    animationiteration: "AnimationIteration",
    animationstart: "AnimationStart",
    beforeinput: "BeforeInput",
    blur: null,
    change: null,
    click: null,
    contextmenu: "ContextMenu",
    copy: null,
    cut: null,
    dblclick: "DoubleClick",
    drag: null,
    dragend: "DragEnd",
    dragenter: "DragEnter",
    dragexit: "DragExit",
    dragleave: "DragLeave",
    dragover: "DragOver",
    dragstart: "DragStart",
    drop: null,
    error: null,
    focus: null,
    focusin: "FocusIn",
    focusout: "FocusOut",
    gotpointercapture: "GotPointerCapture",
    input: null,
    invalid: null,
    keydown: "KeyDown",
    keypress: "KeyPress",
    keyup: "KeyUp",
    load: null,
    lostpointercapture: "LostPointerCapture",
    mousedown: "MouseDown",
    mouseenter: "MouseEnter",
    mouseleave: "MouseLeave",
    mousemove: "MouseMove",
    mouseout: "MouseOut",
    mouseover: "MouseOver",
    mouseup: "MouseUp",
    paste: null,
    pointercancel: "PointerCancel",
    pointerdown: "PointerDown",
    pointerenter: "PointerEnter",
    pointerleave: "PointerLeave",
    pointermove: "PointerMove",
    pointerout: "PointerOut",
    pointerover: "PointerOver",
    pointerup: "PointerUp",
    reset: null,
    scroll: null,
    select: null,
    submit: null,
    toggle: null,
    touchcancel: "TouchCancel",
    touchend: "TouchEnd",
    touchmove: "TouchMove",
    touchstart: "TouchStart",
    transitionend: "TransitionEnd",
    wheel: null,
};
const isCommonEventName = (lowercaseEventName) => Object.prototype.hasOwnProperty.call(COMMON_EVENTS, lowercaseEventName);
const getCommonEventHandlerName = (lowercaseEventName) => {
    var _a;
    return `on${(_a = COMMON_EVENTS[lowercaseEventName]) !== null && _a !== void 0 ? _a : lowercaseEventName[0].toUpperCase() + lowercaseEventName.slice(1).toLowerCase()}`;
};
const rule = {
    meta: {
        type: "problem",
        docs: {
            recommended: "warn",
            description: "Enforce naming DOM element event handlers consistently and prevent Solid's analysis from misunderstanding whether a prop should be an event handler.",
            url: "https://github.com/joshwilsonvu/eslint-plugin-solid/blob/main/docs/event-handlers.md",
        },
        fixable: "code",
        hasSuggestions: true,
        schema: [
            {
                type: "object",
                properties: {
                    ignoreCase: {
                        type: "boolean",
                        description: "if true, don't warn on ambiguously named event handlers like `onclick` or `onchange`",
                        default: false,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            "detected-attr": 'The {{name}} prop is named as an event handler (starts with "on"), but Solid knows its value ({{staticValue}}) is a string or number, so it will be treated as an attribute. If this is intentional, name this prop attr:{{name}}.',
            naming: "The {{name}} prop is ambiguous. If it is an event handler, change it to {{handlerName}}. If it is an attribute, change it to {{attrName}}.",
            capitalization: "The {{name}} prop should be renamed to {{fixedName}} for readability.",
            "make-handler": "Change the {{name}} prop to {{handlerName}}.",
            "make-attr": "Change the {{name}} prop to {{attrName}}.",
            "spread-handler": "The {{name}} prop should be added as a JSX attribute, not spread in. Solid doesn't add listeners when spreading into JSX.",
        },
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        return {
            JSXAttribute(node) {
                var _a, _b, _c;
                const openingElement = node.parent;
                if (openingElement.name.type !== "JSXIdentifier" ||
                    !(0, utils_2.isDOMElementName)(openingElement.name.name)) {
                    return;
                }
                if (node.name.type === "JSXNamespacedName") {
                    return;
                }
                const { name } = node.name;
                const match = /^on([a-zA-Z].*)$/.exec(name);
                if (!match) {
                    return;
                }
                let staticValue = null;
                if (((_a = node.value) === null || _a === void 0 ? void 0 : _a.type) === "JSXExpressionContainer" &&
                    node.value.expression.type !== "JSXEmptyExpression" &&
                    node.value.expression.type !== "ArrayExpression" &&
                    (staticValue = getStaticValue(node.value.expression, context.getScope())) !== null &&
                    (typeof staticValue.value === "string" || typeof staticValue.value === "number")) {
                    context.report({
                        node: node,
                        messageId: "detected-attr",
                        data: {
                            name,
                            staticValue: staticValue.value,
                        },
                    });
                }
                else if (node.value === null || ((_b = node.value) === null || _b === void 0 ? void 0 : _b.type) === "Literal") {
                    context.report({
                        node: node,
                        messageId: "detected-attr",
                        data: {
                            name,
                            staticValue: node.value !== null ? node.value.value : true,
                        },
                    });
                }
                else if (!((_c = context.options[0]) === null || _c === void 0 ? void 0 : _c.ignoreCase)) {
                    const lowercaseEventName = match[1].toLowerCase();
                    if (isCommonEventName(lowercaseEventName)) {
                        const fixedName = getCommonEventHandlerName(lowercaseEventName);
                        if (fixedName !== name) {
                            context.report({
                                node: node.name,
                                messageId: "capitalization",
                                data: { name, fixedName },
                                fix: (fixer) => fixer.replaceText(node.name, fixedName),
                            });
                        }
                    }
                    else if (name[2] === name[2].toLowerCase()) {
                        const handlerName = `on${match[1][0].toUpperCase()}${match[1].slice(1)}`;
                        const attrName = `attr:${name}`;
                        context.report({
                            node: node.name,
                            messageId: "naming",
                            data: { name, attrName, handlerName },
                            suggest: [
                                {
                                    messageId: "make-handler",
                                    data: { name, handlerName },
                                    fix: (fixer) => fixer.replaceText(node.name, handlerName),
                                },
                                {
                                    messageId: "make-attr",
                                    data: { name, attrName },
                                    fix: (fixer) => fixer.replaceText(node.name, attrName),
                                },
                            ],
                        });
                    }
                }
            },
            "JSXSpreadAttribute > ObjectExpression > Property"(node) {
                const openingElement = node.parent.parent.parent;
                if (openingElement.name.type === "JSXIdentifier" &&
                    (0, utils_2.isDOMElementName)(openingElement.name.name)) {
                    if (node.key.type === "Identifier" && /^on/.test(node.key.name)) {
                        const handlerName = node.key.name;
                        context.report({
                            node,
                            messageId: "spread-handler",
                            data: {
                                name: node.key.name,
                            },
                            fix: (fixer) => [
                                fixer.remove(node),
                                fixer.insertTextAfter(node.parent.parent, ` ${handlerName}={${sourceCode.getText(node.value)}}`),
                            ],
                        });
                    }
                }
            },
        };
    },
};
exports.default = rule;
